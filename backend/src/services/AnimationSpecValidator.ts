/**
 * AnimationSpecValidator Service
 * Validates three.js animation specifications generated by Gemini
 * Ensures structure, geometry, materials, and optional animations are valid
 */

import type { Animation3D, AnimationClip } from '@/types/index';
import { ValidationError } from '@/services/ErrorHandler';

/**
 * Validate animation specification structure
 */
export function validateAnimationSpec(spec: unknown): Animation3D {
  if (!spec || typeof spec !== 'object') {
    throw new ValidationError('Animation spec must be a valid object', 'animationSpec');
  }

  const specObj = spec as Record<string, any>;

  // Validate metadata
  if (!specObj.metadata || typeof specObj.metadata !== 'object') {
    throw new ValidationError('Animation spec must include metadata', 'metadata');
  }

  const metadata = specObj.metadata as Record<string, any>;
  if (!metadata.version || typeof metadata.version !== 'string') {
    throw new ValidationError('Metadata must include version string', 'metadata.version');
  }

  if (!metadata.type || typeof metadata.type !== 'string') {
    throw new ValidationError('Metadata must include type string', 'metadata.type');
  }

  if (!metadata.generator || typeof metadata.generator !== 'string') {
    throw new ValidationError('Metadata must include generator name', 'metadata.generator');
  }

  // Validate object (three.js Object3D structure)
  if (!specObj.object || typeof specObj.object !== 'object') {
    throw new ValidationError('Animation spec must include object definition', 'object');
  }

  const objectDef = specObj.object as Record<string, any>;
  if (typeof objectDef.uuid !== 'string') {
    throw new ValidationError('Object must have uuid property', 'object.uuid');
  }

  // Validate geometries array
  if (!Array.isArray(specObj.geometries)) {
    throw new ValidationError('Animation spec must include geometries array', 'geometries');
  }

  // Validate materials array
  if (!Array.isArray(specObj.materials)) {
    throw new ValidationError('Animation spec must include materials array', 'materials');
  }

  // Validate materials have valid structure
  for (let i = 0; i < specObj.materials.length; i++) {
    const material = specObj.materials[i];
    if (!material || typeof material !== 'object') {
      throw new ValidationError(`Material at index ${i} is invalid`, `materials[${i}]`);
    }

    const matObj = material as Record<string, any>;
    if (typeof matObj.uuid !== 'string') {
      throw new ValidationError(`Material at index ${i} must have uuid`, `materials[${i}].uuid`);
    }

    if (!matObj.type || typeof matObj.type !== 'string') {
      throw new ValidationError(`Material at index ${i} must have type`, `materials[${i}].type`);
    }
  }

  // Validate animations array if present
  if (specObj.animations) {
    if (!Array.isArray(specObj.animations)) {
      throw new ValidationError('Animations must be an array', 'animations');
    }

    for (let i = 0; i < specObj.animations.length; i++) {
      const animation = specObj.animations[i];
      if (!animation || typeof animation !== 'object') {
        throw new ValidationError(`Animation at index ${i} is invalid`, `animations[${i}]`);
      }

      const animObj = animation as Record<string, any>;
      if (!animObj.name || typeof animObj.name !== 'string') {
        throw new ValidationError(`Animation at index ${i} must have name`, `animations[${i}].name`);
      }

      if (typeof animObj.duration !== 'number' || animObj.duration <= 0) {
        throw new ValidationError(
          `Animation at index ${i} must have valid duration`,
          `animations[${i}].duration`
        );
      }

      if (!Array.isArray(animObj.tracks)) {
        throw new ValidationError(
          `Animation at index ${i} must have tracks array`,
          `animations[${i}].tracks`
        );
      }
    }
  }

  // Return validated spec (with unknown types preserved as per spec)
  return {
    metadata: {
      version: metadata.version as string,
      type: metadata.type as string,
      generator: metadata.generator as string,
    },
    object: specObj.object,
    geometries: specObj.geometries,
    materials: specObj.materials,
    animations: specObj.animations || [],
  };
}

/**
 * Validate that animation spec can be rendered
 * Checks for common issues that would prevent rendering
 */
export function validateRenderability(spec: Animation3D): void {
  // Check that object references valid materials
  const materialUuids = new Set(
    spec.materials.map((m) => {
      if (m && typeof m === 'object') {
        const matObj = m as Record<string, any>;
        return matObj.uuid;
      }
      return undefined;
    }).filter(Boolean)
  );

  // Validate object structure references materials correctly
  validateObjectMaterials(spec.object, materialUuids);
}

/**
 * Recursively validate object material references
 */
function validateObjectMaterials(obj: any, validMaterialUuids: Set<string>): void {
  if (!obj || typeof obj !== 'object') {
    return;
  }

  const objData = obj as Record<string, any>;

  // Check direct material reference
  if (objData.material) {
    if (typeof objData.material === 'string' && !validMaterialUuids.has(objData.material)) {
      throw new ValidationError(
        `Object references invalid material UUID: ${objData.material}`,
        'object.material'
      );
    }
  }

  // Check material array
  if (Array.isArray(objData.materials)) {
    for (const matRef of objData.materials) {
      if (typeof matRef === 'string' && !validMaterialUuids.has(matRef)) {
        throw new ValidationError(
          `Object references invalid material UUID: ${matRef}`,
          'object.materials'
        );
      }
    }
  }

  // Recursively check children
  if (Array.isArray(objData.children)) {
    for (const child of objData.children) {
      validateObjectMaterials(child, validMaterialUuids);
    }
  }
}

/**
 * Estimate spec file size for bandwidth optimization
 */
export function estimateSpecSize(spec: Animation3D): number {
  // Rough estimation: convert to JSON and measure byte size
  try {
    const json = JSON.stringify(spec);
    // UTF-8 encoding: most characters are 1-4 bytes
    const bytes = new TextEncoder().encode(json).length;
    return bytes;
  } catch {
    return 0;
  }
}

/**
 * Get animation duration from spec
 */
export function getTotalAnimationDuration(spec: Animation3D): number {
  if (!spec.animations || spec.animations.length === 0) {
    return 0;
  }

  let maxDuration = 0;
  for (const animation of spec.animations) {
    if (animation && typeof animation === 'object') {
      const animObj = animation as Record<string, any>;
      if (typeof animObj.duration === 'number' && animObj.duration > maxDuration) {
        maxDuration = animObj.duration;
      }
    }
  }

  return maxDuration;
}

/**
 * Get list of animation names from spec
 */
export function getAnimationNames(spec: Animation3D): string[] {
  if (!spec.animations || spec.animations.length === 0) {
    return [];
  }

  return spec.animations
    .map((_animation: AnimationClip) => {
      if (_animation && typeof _animation === 'object') {
        const animObj = _animation as Record<string, any>;
        return animObj.name as string | undefined;
      }
      return undefined;
    })
    .filter((_name: string | undefined): _name is string => typeof _name === 'string');
}

/**
 * Sanitize animation spec to remove potentially problematic content
 * Useful for security and performance
 */
export function sanitizeAnimationSpec(spec: Animation3D): Animation3D {
  // Create deep copy to avoid mutation
  const sanitized: Animation3D = {
    metadata: { ...spec.metadata },
    object: JSON.parse(JSON.stringify(spec.object)) as unknown,
    geometries: spec.geometries.map((_g: unknown) => JSON.parse(JSON.stringify(_g))),
    materials: spec.materials.map((_m: unknown) => JSON.parse(JSON.stringify(_m))),
    animations: spec.animations.map((_a: AnimationClip) => JSON.parse(JSON.stringify(_a))),
  };

  // Remove excessive geometry vertices to prevent client memory issues
  // Warn if any geometry has > 1M vertices
  for (const geometry of sanitized.geometries) {
    if (geometry && typeof geometry === 'object') {
      const geomObj = geometry as Record<string, any>;
      if (Array.isArray(geomObj.data?.position)) {
        const vertexCount = geomObj.data.position.length / 3;
        if (vertexCount > 1_000_000) {
          console.warn(
            `Geometry has ${vertexCount} vertices, which may impact client performance`
          );
        }
      }
    }
  }

  return sanitized;
}
