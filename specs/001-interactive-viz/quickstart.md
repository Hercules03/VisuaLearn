# Developer Quickstart: AI-Powered Interactive 3D Concept Visualizer

**Date**: 2025-11-24 | **Project**: visuaLearn (001-interactive-viz)

---

## Project Overview

Build an interactive web app that transforms educational concepts into animated 3D visualizations using:
- **Frontend**: React 18+ with TypeScript, React-Three-Fiber, i18next
- **Backend**: Node.js 18+ with TypeScript, Express/Fastify, Gemini API
- **Storage**: Session-local (Redis or in-memory), no persistent database
- **Deployment**: Vercel (frontend), AWS ECS / Railway (backend)

**Core Flow**: User inputs concept → Backend calls Gemini → Returns three.js JSON + explanation → Frontend renders interactive 3D scene → User can export (GLB/JSON/SVG).

---

## Prerequisites

- **Node.js**: 18+ (check with `node --version`)
- **npm**: 9+ or **pnpm** 8+
- **Git**: For version control
- **API Keys**:
  - Google Gemini API key (free tier available)
  - Claude API key (for translation, optional)
- **Redis** (optional, recommended for multi-instance deployment)

---

## Project Structure

```
visuaLearn/
├── frontend/                          # React app
│   ├── src/
│   │   ├── components/                # React components
│   │   │   ├── ConceptInputForm.tsx
│   │   │   ├── ExplanationPanel.tsx
│   │   │   ├── ThreeJSViewer.tsx
│   │   │   ├── ControlsPanel.tsx
│   │   │   ├── ExportModal.tsx
│   │   │   └── LanguageSwitcher.tsx
│   │   ├── services/                  # API calls, utilities
│   │   │   ├── ConceptService.ts
│   │   │   └── ExportService.ts
│   │   ├── config/
│   │   │   └── i18n.ts               # i18next setup
│   │   ├── App.tsx                   # Main layout
│   │   └── index.tsx                 # Entry point
│   ├── public/
│   │   └── locales/                  # Translation files
│   │       ├── en/common.json
│   │       └── ja/common.json
│   ├── vite.config.ts                # Vite build config
│   └── package.json
│
├── backend/                           # Node.js API server
│   ├── src/
│   │   ├── services/                 # Business logic
│   │   │   ├── InputValidator.ts
│   │   │   ├── GeminiService.ts
│   │   │   ├── AnimationSpecValidator.ts
│   │   │   ├── TranslationService.ts
│   │   │   ├── ExportService.ts
│   │   │   └── CacheManager.ts
│   │   ├── controllers/              # Route handlers
│   │   │   ├── ConceptController.ts
│   │   │   └── ExportController.ts
│   │   ├── middleware/               # Express/Fastify middleware
│   │   │   ├── RateLimiter.ts
│   │   │   └── ErrorHandler.ts
│   │   ├── app.ts                    # Server setup
│   │   └── index.ts                  # Entrypoint
│   ├── tests/                        # Test files
│   │   ├── unit/
│   │   ├── integration/
│   │   └── e2e/
│   ├── Dockerfile                    # Container image
│   ├── .env.example                  # Environment template
│   └── package.json
│
├── specs/
│   └── 001-interactive-viz/
│       ├── spec.md                   # Feature specification
│       ├── plan.md                   # Implementation plan (this file context)
│       ├── data-model.md             # Entity definitions
│       └── tasks.md                  # Task breakdown (generated by /speckit.tasks)
│
├── .github/
│   └── workflows/
│       ├── lint-test.yml             # CI pipeline
│       └── deploy.yml                # CD pipeline
│
└── README.md
```

---

## Local Setup

### 1. Clone & Install

```bash
git clone <repo-url>
cd visuaLearn
git checkout 001-interactive-viz   # Feature branch

# Install dependencies
cd frontend && npm install && cd ..
cd backend && npm install && cd ..
```

### 2. Environment Variables

**Frontend** (`.env.local` or `.env`):
```
VITE_API_URL=http://localhost:3000/api
```

**Backend** (`.env`):
```
GEMINI_API_KEY=<your-gemini-key>
CLAUDE_API_KEY=<your-claude-key>       # Optional, for translations
REDIS_URL=redis://localhost:6379      # Optional (defaults to in-memory)
PORT=3000
NODE_ENV=development
```

### 3. Run Locally

**Terminal 1: Frontend**
```bash
cd frontend
npm run dev
# Opens http://localhost:5173
```

**Terminal 2: Backend**
```bash
cd backend
npm run dev
# Runs on http://localhost:3000/api
```

**Terminal 3: Redis (optional, if using Redis)**
```bash
redis-server     # or `docker run -p 6379:6379 redis`
```

### 4. Verify Setup

**Frontend**:
- Open http://localhost:5173
- Should see "Concept Visualizer" form
- Language selector visible (EN / JA)

**Backend**:
- Check http://localhost:3000/health (or similar health endpoint)
- Should return `{ status: "ok" }`

**Test Concept**:
1. Enter concept: "photosynthesis"
2. Select depth: "intro"
3. Select language: "English"
4. Click submit
5. Wait 3-5 seconds for Gemini API
6. Should see explanation text + interactive 3D scene
7. Try adjusting speed slider, rotating camera, toggling layers

---

## Key Development Tasks

### Frontend Development

**Component: ConceptInputForm**
- Input field for concept (max 200 chars)
- Dropdown for depth level
- Language selector
- Submit button
- Error message display
- Form validation (required fields, input rules)

**Component: ThreeJSViewer**
- React-Three-Fiber Canvas
- Load three.js JSON from API
- Camera controls (rotate, zoom, pan)
- Touch gesture support
- WebGL detection + fallback

**Component: ControlsPanel**
- Play/pause button
- Speed slider (0.5x to 2x)
- Seek bar
- Layer toggles (dynamically populated)

**Component: ExportModal**
- Format selector (GLB, JSON, SVG)
- Resolution/options customizer
- Download button
- Progress indicator

### Backend Development

**Service: InputValidator**
- Check concept length (>2 words)
- Blocklist keyword check
- Return error message if invalid

**Service: GeminiService**
- Call Gemini API with structured prompt
- Parse three.js JSON response
- Timeout handling (30s)
- Error wrapping (user-friendly messages)

**Service: TranslationService**
- Cache check (Redis)
- Call Claude API if not cached
- Cache result (1 week TTL)
- Return translated text

**Service: ExportService**
- Generate GLB via three.js GLTFExporter
- Generate JSON via scene.toJSON()
- Generate SVG via SVGRenderer or custom projection
- Stream large files (>50MB)

**Middleware: RateLimiter**
- Track requests per session (10/min limit)
- Return 429 if exceeded
- Clean up old counters (session expiry)

---

## Testing

### Unit Tests

**Run**:
```bash
cd frontend && npm test
cd backend && npm test
```

**Coverage Target**: ≥80%

**Key Tests**:
- InputValidator: Valid/invalid concepts
- GeminiService: Prompt construction, response parsing, timeouts
- TranslationService: Cache hits/misses, API calls
- ExportService: GLB/JSON/SVG generation
- Components: Render, user interaction, state updates

### Integration Tests

**Run**:
```bash
cd backend && npm run test:integration
```

**Scope**:
- API contract (request → response)
- Gemini API wrapper (end-to-end)
- TranslationService (cache + API)
- ExportService (file generation)

### E2E Tests (Playwright)

**Run**:
```bash
npm run test:e2e
```

**Scenarios**:
1. User submits concept → sees explanation + 3D
2. User adjusts controls → scene updates
3. User exports GLB → file downloads
4. User switches language → UI + content translated
5. User submits invalid concept → error shown

---

## Common Development Workflows

### Add a New Component

1. Create file: `frontend/src/components/MyComponent.tsx`
2. Define TypeScript interface for props
3. Implement component using React hooks
4. Add to `App.tsx` or parent component
5. Write unit tests: `MyComponent.test.tsx`
6. Use in other components via import

### Call Backend API

```typescript
// frontend/src/services/ConceptService.ts
import axios from 'axios';

const API_URL = import.meta.env.VITE_API_URL;

export async function generateConcept(concept: string, depth: string, language: string) {
  const response = await axios.post(`${API_URL}/concepts`, {
    concept,
    depth,
    language
  });
  return response.data;
}
```

### Add Backend Endpoint

```typescript
// backend/src/controllers/ConceptController.ts
export async function handleConcept(req: Request, res: Response) {
  const { concept, depth, language } = req.body;

  // Validate
  if (!isValid(concept)) {
    return res.status(400).json({ error: 'Invalid concept' });
  }

  // Generate
  const result = await GeminiService.generateConcept(concept, depth);

  // Translate if needed
  const translated = await TranslationService.translate(result.explanation, language);

  // Return
  return res.json({
    explanationText: translated,
    animationSpec: result.spec
  });
}
```

### Handle Errors

**Frontend**:
```typescript
try {
  const result = await ConceptService.generateConcept(concept, depth, language);
  setState(result);
} catch (error) {
  showError(error.message || 'Failed to generate visualization');
}
```

**Backend**:
```typescript
// All errors caught by ErrorHandler middleware
// Return HTTP status + JSON error response
res.status(500).json({
  error: 'Service temporarily unavailable. Try again in a moment.'
});
```

---

## Debugging

### Frontend

**Vite DevServer**:
- Hot Module Replacement (HMR) enabled
- React DevTools browser extension recommended
- Console logs in browser DevTools

**Three.js Debugging**:
```typescript
// In ThreeJSViewer.tsx
const scene = new THREE.Scene();
window.debugScene = scene;  // Access in console: window.debugScene
```

### Backend

**Structured Logging**:
```typescript
import logger from './logger';  // Winston or Pino

logger.info('Generating concept', { concept, depth });
logger.error('Gemini API failed', { error, concept });
```

**Environment Variables**:
- Set `NODE_ENV=debug` for verbose logging
- Check `.env` and `.env.local`

### API Testing

**Postman/Insomnia**:
1. Create POST request to `http://localhost:3000/api/concepts`
2. Body (JSON):
   ```json
   {
     "concept": "photosynthesis",
     "depth": "intro",
     "language": "en"
   }
   ```
3. Headers: `Content-Type: application/json`
4. Send & inspect response

**curl**:
```bash
curl -X POST http://localhost:3000/api/concepts \
  -H "Content-Type: application/json" \
  -d '{"concept":"photosynthesis","depth":"intro","language":"en"}'
```

---

## Building for Production

### Frontend Build

```bash
cd frontend
npm run build
# Output: dist/ folder (static files for Vercel/CDN)
```

### Backend Build

```bash
cd backend
npm run build
# Output: dist/ folder (compiled JavaScript)

docker build -t visualearn-api .
docker push <registry>/visualearn-api:latest
```

### Deploy

**Frontend (Vercel)**:
```bash
vercel --prod
```

**Backend (AWS ECS / Railway / Render)**:
- Push Docker image to registry
- Update deployment config
- Redeploy

---

## Performance Tips

1. **Frontend**:
   - Use React.memo for expensive components (ThreeJSViewer)
   - Lazy load animations using Suspense
   - Code-split export logic

2. **Backend**:
   - Cache Gemini responses (1 week TTL)
   - Cache translations (1 week TTL)
   - Implement request deduplication (avoid duplicate API calls)

3. **3D Rendering**:
   - Simplify geometries for low-end devices
   - Use LOD (Level of Detail) for complex scenes
   - Test on mobile (iPad Air, Galaxy Tab)

---

## Troubleshooting

| Issue | Cause | Fix |
|-------|-------|-----|
| "Cannot find module" | Missing dependency | `npm install` in correct directory |
| Gemini API 401 error | Invalid API key | Check `.env`, regenerate key |
| CORS error | Frontend/backend mismatch | Verify `VITE_API_URL` matches backend URL |
| 3D scene doesn't render | WebGL unavailable | Check browser support, use fallback SVG |
| Rate limit exceeded | Too many rapid requests | Wait 60 seconds, implement debounce |
| Redis connection error | Redis not running | Start Redis: `redis-server` |
| Language not switching | i18next misconfigured | Check `public/locales/` files exist |

---

## Resources

- **React-Three-Fiber Docs**: https://docs.pmnd.rs/react-three-fiber/
- **three.js Docs**: https://threejs.org/docs/
- **Gemini API Docs**: https://ai.google.dev/
- **i18next Docs**: https://www.i18next.com/
- **Express/Fastify**: https://expressjs.com/ or https://www.fastify.io/
- **Vite Docs**: https://vitejs.dev/

---

## Next Steps

1. **Set up development environment** (Node, npm, API keys)
2. **Implement Phase 1 components** (follow task breakdown in `/speckit.tasks`)
3. **Write unit tests** for each service/component
4. **Run integration tests** before merging PRs
5. **Deploy to staging** (verify on real infrastructure)
6. **Gather user feedback** (P1: student learning, P2: teacher export)
7. **Iterate and optimize**

---

## Questions?

Refer to:
- Spec: `specs/001-interactive-viz/spec.md`
- Plan: `specs/001-interactive-viz/plan.md`
- Data Model: `specs/001-interactive-viz/data-model.md`
- Constitution: `.specify/memory/constitution.md`
