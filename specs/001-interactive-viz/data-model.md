# Data Model: AI-Powered Interactive 3D Concept Visualizer

**Date**: 2025-11-24 | **Feature**: [spec.md](./spec.md) | **Plan**: [plan.md](./plan.md)

---

## Core Entities

### 1. ConceptRequest (Ephemeral)

**Purpose**: Represents user's input for concept visualization.

**Fields**:
- `id`: string (UUID, session-unique identifier)
- `concept`: string (max 200 characters; validated: >2 words, no blocklist keywords)
- `depth`: enum [`intro` | `intermediate` | `advanced`]
- `language`: enum [`en` | `ja`]
- `timestamp`: ISO 8601 (when submitted)

**Validation Rules**:
- `concept` MUST be >2 words
- `concept` MUST NOT contain single-character tokens
- `concept` MUST NOT contain blocklist keywords (bomb, exploit, malware, etc.)
- Max length: 200 characters
- Multi-language input treated as opaque string (no language detection)

**Lifecycle**:
- Created: User submits concept form
- Retained: Session duration (max 1 hour)
- Deleted: Session ends or server restart

**No Persistence**: Not saved to database; stored in-memory or Redis cache only.

---

### 2. AnimationSpec (Session-Local)

**Purpose**: Represents the 3D scene specification generated by Gemini.

**Fields**:
- `conceptId`: string (foreign key to ConceptRequest.id)
- `threejsObject`: Object3D (three.js JSON format)
  - `object`: { type, name, uuid, geometry, material, position, rotation, scale, ... }
  - `geometries`: Array of geometry definitions
  - `materials`: Array of material definitions
  - `animations`: Array of animation clips
  - `metadata`: { depth, concept, generatedAt, ...}

**Structure** (three.js Object3D JSON Format):
```json
{
  "metadata": {
    "version": "4.5",
    "type": "Object3D",
    "generator": "Object3D.toJSON"
  },
  "object": {
    "uuid": "<uuid>",
    "type": "Group",
    "name": "<concept-name>",
    "matrix": [...],
    "children": [...]
  },
  "geometries": [...],
  "materials": [...],
  "animations": [...]
}
```

**Validation Rules**:
- Must be valid JSON
- Must conform to three.js Object3D schema
- Must contain at least one geometry
- Must contain at least one material
- Animations optional but recommended

**Lifecycle**:
- Created: Gemini API returns response
- Stored: In-session cache (memory or Redis)
- Expires: Session end or 1 week TTL (for cache)
- Used: Rendering in 3D viewer, export generation

**Cache Key**: `animation:{conceptId}` or `animation:{hash(concept+depth)}`

---

### 3. ExplanationText (Session-Local)

**Purpose**: AI-generated text explanation in user's selected language.

**Fields**:
- `id`: string (UUID)
- `conceptId`: string (foreign key)
- `language`: enum [`en` | `ja`]
- `originalText`: string (generated by Gemini in English)
- `translatedText`: string (translated to user's language if not EN)
- `wordCount`: number (<1000)
- `structure`: object
  - `headings`: Array of section headings
  - `hasLists`: boolean (bullet points or numbered)
  - `hasTables`: boolean (structured data)
- `generatedAt`: ISO 8601
- `translatedAt`: ISO 8601 (if applicable)

**Validation Rules**:
- `wordCount` MUST be <1000
- `language` MUST match user's selected preference
- `originalText` MUST NOT contain system prompts or artifacts
- `translatedText` MUST be fluent in target language (no machine gibberish)

**Lifecycle**:
- Created: Gemini API returns explanation (in English)
- Translated: TranslationService called if language != EN
- Cached: With TTL (1 week for popular concepts)
- Displayed: In ExplanationPanel component
- Deleted: Session end

---

### 4. ExportPackage (On-Demand)

**Purpose**: Represents exported 3D visualization in one of three formats.

**Fields**:
- `id`: string (UUID)
- `conceptId`: string (foreign key)
- `format`: enum [`glb` | `json` | `svg`]
- `resolution`: enum [`720p` | `1080p` | `2k`]
- `includeAnnotations`: boolean
- `includedLayers`: Array<string> (subset of scene layers)
- `fileSize`: number (bytes)
- `fileName`: string (e.g., "photosynthesis-export.glb")
- `data`: binary or text (file content)
- `generatedAt`: ISO 8601
- `expiresAt`: ISO 8601 (for download URLs, typically 1 hour)

**Format-Specific Details**:

**GLB (glTF 2.0 Binary)**:
- Mimetype: `model/gltf-binary`
- Contains: Geometry, materials, animations, textures
- Generation: three.js GLTFExporter
- Typical size: 5-50MB

**JSON (three.js JSON)**:
- Mimetype: `application/json`
- Contains: Scene graph, geometries, materials, animations, metadata
- Generation: scene.toJSON() serialization
- Typical size: 1-10MB
- Embeddable: Yes (can be included in HTML/JS)

**SVG (2D Projection)**:
- Mimetype: `image/svg+xml`
- Contains: 2D projection of 3D scene, annotations, labels
- Generation: three.js SVGRenderer or custom projection
- Typical size: 500KB-5MB
- Web-embeddable: Yes

**Validation Rules**:
- File MUST conform to format specification (glTF 2.0, valid JSON, valid SVG)
- File size MUST match declared `fileSize`
- GLB files MUST be openable in 3 major viewers (three.js, Babylon.js, Blender)

**Lifecycle**:
- Created: User clicks Export, selects format/options
- Generated: Backend generates file from animation spec
- Returned: Download URL (signed URL for cloud storage) or direct stream
- Expires: After 1 hour (if URL-based); user deletes after download
- Not persisted: No database storage

---

## State Transitions

### User Session State Machine

```
┌─────────────┐
│   Idle      │ (initial state)
│ - Form      │
│ - No result │
└─────┬───────┘
      │ User submits concept
      ↓
┌──────────────────┐
│  Generating      │
│ - Fetching Gemini│
│ - Loading 3D spec│
│ - Translating    │
└─────┬────────────┘
      │ Success
      ↓
┌─────────────┐
│   Ready     │ (cached state)
│ - Display 3D│
│ - Show text │
│ - Enable    │
│   export    │
└──┬───────┬──┘
   │       │ User enters new concept
   │       └──→ Idle
   │
   │ User clicks export
   ↓
┌──────────────┐
│  Exporting   │
│ - Generate   │
│   file       │
└─────┬────────┘
      │ Success
      ↓
┌──────────────┐
│ Downloaded   │
│ - File sent  │
│ - Cleanup    │
└──────────────┘
      OR
      │ Error (user retries)
      └──→ Ready or Idle
```

**State Details**:

| State | Duration | Data Retained | User Actions Available |
|-------|----------|---------------|----------------------|
| **Idle** | Session start | None | Enter concept, change language/depth |
| **Generating** | 3-5 seconds | Form input, request queued | Cancel (optional) |
| **Ready** | 1 hour max | Concept + spec + explanation | Adjust controls, export, new concept |
| **Exporting** | 1-5 seconds | All above + file being generated | None (modal disabled) |
| **Downloaded** | Instant | Temporary (cleanup) | New concept or session end |

**Error Paths**:
- Input validation fails → Idle (show error message)
- Gemini timeout → Idle or Ready (show error, allow retry)
- Export generation fails → Ready (show error, allow retry)

---

## Data Flow Diagrams

### Concept Generation Flow

```
User Input (concept, depth, language)
  ↓
InputValidator (check >2 words, blocklist)
  ├─ Valid → Continue
  └─ Invalid → Return error, stay in Idle
  ↓
CheckCache (hash(concept+depth))
  ├─ Cache hit → Return cached result, skip to Ready
  └─ Cache miss → Call Gemini
  ↓
GeminiService (Gemini API)
  ├─ Input: concept, depth (EN), structured prompt
  └─ Output: three.js JSON + explanation text (EN)
  ↓
AnimationSpecValidator (validate three.js JSON)
  ├─ Valid → Continue
  └─ Invalid → Return error, stay in Idle
  ↓
TranslationService (if language != EN)
  ├─ Input: explanation text (EN), target language
  ├─ Check translation cache (hit → skip API)
  ├─ Call Claude API (miss)
  └─ Cache result (TTL 1 week)
  ↓
Store in session cache (memory or Redis)
  ├─ Key: animation:{conceptId}
  ├─ TTL: 1 week (for cache reuse)
  └─ Value: { animationSpec, explanation, timestamp }
  ↓
Return to Frontend
  ├─ Render: 3D scene in ThreeJSViewer
  ├─ Display: Explanation text
  └─ Enable: Controls, export button
  ↓
State: Ready
```

### Export Flow

```
User Clicks Export
  ↓
ExportModal Opens
  ├─ User selects format (GLB/JSON/SVG)
  ├─ User customizes options (resolution, layers, annotations)
  └─ User clicks Download
  ↓
ExportService (backend)
  ├─ Retrieve animation spec from cache
  ├─ Apply customizations (filter layers, set resolution)
  ├─ Generate file:
  │  ├─ GLB: three.js GLTFExporter → binary glTF
  │  ├─ JSON: scene.toJSON() serialization
  │  └─ SVG: custom 2D projection
  └─ Validate file format
  ↓
Return File (200 OK)
  ├─ For files <50MB: Direct download
  └─ For files >50MB: Streaming with HTTP 206 Range requests
  ↓
Frontend
  ├─ Download initiated (browser saves file)
  └─ Modal closes, return to Ready state
```

---

## Caching Strategy

### Cache Layers

**Layer 1: Request-Level Cache** (in-memory, per-instance)
- Purpose: Avoid duplicate Gemini calls within same request
- Key: `generating:{hash(concept+depth)}`
- TTL: 5 minutes (request processing window)
- Use: Deduplication if user submits same concept twice quickly

**Layer 2: Session Cache** (Redis or in-memory)
- Purpose: Reuse results within a session
- Key: `session:{sessionId}:concept:{hash(concept+depth)}`
- TTL: 1 hour (session duration)
- Use: User refreshes page or requests same concept again

**Layer 3: Global Cache** (Redis)
- Purpose: Reuse popular concepts across all sessions
- Key: `concept:{hash(concept+depth)}`
- TTL: 1 week
- Use: Reduce Gemini API calls for frequently-requested concepts

**Layer 4: Translation Cache** (Redis)
- Purpose: Reuse translations
- Key: `translation:{language}:{hash(explanationText)}`
- TTL: 1 week
- Use: Reduce Claude API calls for similar explanations

### Cache Invalidation

- **On Cache Hit**: Return immediately (skip Gemini/Claude calls)
- **On Cache Miss**: Generate, store in cache, return
- **No Manual Invalidation**: Concepts are immutable (same concept always generates same result)
- **Cleanup**: Expired entries automatically removed by Redis/LRU eviction

### Cache Size Limits

**In-Memory Cache** (single instance):
- Max entries: 1000 (configurable)
- Eviction: LRU policy
- Risk: Limited to single server instance

**Redis Cache** (shared):
- Max memory: 1GB (configurable, scales up as needed)
- Eviction: LRU policy
- Benefit: Shared across all backend instances

---

## Relationships & Constraints

### Entity Relationships

```
ConceptRequest (1)
  └─── has many ──→ AnimationSpec (many)
  └─── has many ──→ ExplanationText (many)
  └─── has many ──→ ExportPackage (many)

AnimationSpec (1)
  ←─── generated by ──→ Gemini API

ExplanationText (1)
  ├─── original generated by ──→ Gemini API
  └─── translated by (optional) ──→ Claude API

ExportPackage (1)
  ←─── generated from ──→ AnimationSpec
  └─── uses ──→ ExportService
```

### Uniqueness & Keys

- **ConceptRequest**: ID is unique per request; concept+depth+language is unique per session
- **AnimationSpec**: Unique per concept+depth combination (same concept always yields same spec)
- **ExplanationText**: Unique per concept+depth+language combination
- **ExportPackage**: Unique per export request; no uniqueness constraint across exports

### Constraints

- `ConceptRequest.concept`: NOT NULL, length > 2, no blocklist keywords
- `AnimationSpec.threejsObject`: NOT NULL, valid three.js JSON
- `ExplanationText.wordCount`: NOT NULL, <1000, >50 (must have meaningful content)
- `ExplanationText.language`: NOT NULL, must match ConceptRequest.language
- `ExportPackage.fileSize`: NOT NULL, >0, ≤50MB (typical), streaming supported up to browser limits

---

## Database Considerations (None - Stateless)

**Per Constitution Principle VI**: No persistent database.

**Storage Strategy**:
- Session data: In-memory or Redis (ephemeral)
- Cache: Redis with TTL (expires after 1 week or session end)
- Generated results: Temporary files in OS temp directory (cleaned up after export)
- User data: None retained

**Why No Database**:
1. No user accounts (no authentication required)
2. No result sharing (single-user per session)
3. No history tracking (users explicitly export if they want to retain results)
4. Simpler compliance (no GDPR data retention obligations)
5. Easier scaling (stateless architecture)

---

## Session Management

### Session Lifecycle

```
Browser Load App
  ↓ (no login)
Generate Session ID (uuid)
  ├─ Store in memory or Redis
  ├─ Bind to HTTP cookie or Bearer token
  ├─ TTL: 1 hour (auto-cleanup)
  └─ Track rate limit (10 req/min)
  ↓
User Interacts
  ├─ All requests include session ID
  ├─ Cache hits scoped to session
  └─ Rate limit checked per session
  ↓
Session Expires (1 hour) OR Browser Closes
  ├─ Delete cache entries for this session
  ├─ Clear rate limit counters
  └─ No data persisted
```

### Session Cookie

```
Set-Cookie: sessionId=<uuid>; HttpOnly; Secure; SameSite=Lax; Max-Age=3600
```

- `HttpOnly`: Prevent JavaScript access (security)
- `Secure`: HTTPS only
- `SameSite=Lax`: CSRF protection
- `Max-Age=3600`: Auto-cleanup after 1 hour

---

## Notes

- **All ephemeral**: No data persists beyond session
- **Cache optional**: System works without cache (slower, more API calls)
- **Three.js JSON**: Standard format ensures compatibility across tools
- **Validation strict**: Reject malformed input or output; no fallbacks
- **Stateless design**: Enables horizontal scaling without session affinity
